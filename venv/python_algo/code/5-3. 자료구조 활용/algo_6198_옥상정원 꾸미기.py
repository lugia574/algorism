# 1 ≤ N ≤ 80,000 //  1 ≤ hi ≤ 1,000,000,000
# 10억에 8만이라 근데 h 는 단순 높이 연산에 큰 비중은 아닌거 같은데
# 그냥 2중 포문 갈기면 될꺼 같은데 결국 1/2N^2 정도야 잉 계산하니까 3,200,000,000 32억이 되버리는데 ㅋㅋ
# 그럼 딴걸로 해야겠는데??  이럼 dp로도 힘들꺼 같고 이분 탐색 조져야할꺼 가튼데?? 근데 뭘 어떻게 조짐???
# 알고 분류 보니까 스택으로 되어있는데??
# https://velog.io/@thguss/백준-6198.-옥상-정원-꾸미기-with.-Python
# 자 답이 왔어요~ 설명 드가자~

# 2중 포문 돌리면서 각각 개체 하나가 얼마나 가냐를 count 하는게 아니라
# 포문 하나를 돌리면서 각 요소가 들어왔을때 stack에 있는 애들이 이거에 해당되는가? 를 따지는거임

# n = 6 [10, 3, 7, 4, 12, 2] 이라고 해보자
# 먼저 for 문들 돌면서 while 조건을 확인해
# 처음에는 당연히 뭐가 없으니까 stack 에 10 넣고 len -1 도 0 되면서 res 는 아무것도 더해지는게 없지
# 자 [10] 들어가 있고 그대로 3 이 왔어 이것도 while 조건에 해당되지 않지 그러니까 append 되면서 [10, 3] 되고 res += 1 이 되지
# 10 입장에서 3 은 볼 수 있는 조건이니까 1로 세어지는거야

# [10, 3] 상태에서 7이 들어왓어 이때는 while 조건에 맞아 떨어지지 3 을 pop 하고 10은 7보다 크니 그대로 끝나고 [10, 7] 이 됨 res += 1 >> res == 2
# 10 입장에서는 3 은 이미 센 상태고 3 입장에서는 7은 조건에 해당 안되지 그러니까 3 이 빠지고 7이 들어 가는거여
# 그리고 10 입장에서 7은 볼 수 있으니까 +1 되는거지

# [10, 7] 에서 4 들어왔지만 역시 [10, 7, 4] 로 끝 res += 2 >> res == 4
# 10, 7 둘다 4 는 조건에 해당되는 놈이야 그니까 각각 +1 +1 해줘서 +2 가 되는거지

# [10, 7, 4] 에서 12 가 들어왔어 캬 이건 다 높아 그러니까 싹 pop 되겠지 그럼 [12] 만 남게 되고 res += 0 >> res ==4
# 12 는 10, 7, 4 세놈 다 조건에 해당 안되는 존나 큰놈이자나
# 그럼 이제 방을 빼야지 다 꺼져버려

# [12] 상태에서 2 는 그대로 append 로 끝 res += 1 >> res == 5 로 끝끝 끝
# 12 만 있는 상태에서 2 가 들어왔어 조건도 맞고 그럼 딱 +1
# print(res) 는 5!
import sys

if __name__ == "__main__":
    input = sys.stdin.readline
    n = int(input())
    arr = [int(input()) for _ in range(n)]
    res = 0
    stack = []

    for x in arr:
        while stack and stack[-1] <= x:
            stack.pop()
        stack.append(x)

        res += len(stack) - 1

    print(res)