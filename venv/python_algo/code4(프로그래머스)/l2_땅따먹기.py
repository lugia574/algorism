# 흠 모두 조져야할꺼 같은데
# 단순히 현재 젤 높은 값만 보고 간다는 걸로는 최대값으로 갈 수 가 없어여
# 그럴려면 이중 포문 갈겨야할텐데 그점에서 행이 4로 고정이니까 대에충 4n 하지 않것어?
# 아닌가 암튼 대에충 DFS 갈기면 되지 않을까
# 는 개같이 시초라네~
# 그래서 찾아보니 무슨 그냥 2중 포문 갈겨버리는거 있는데 그러면 안됨
# 이건 완전 탐색을 해야지 단순히 그리디알고리즘을 써버리면 안되다 이거임
# 가령 [[1,2,3,5],[5,6,7,99999],[4,3,2,1]] 라고 해보자 그러면 무조건 첫 행은 3을 고르고 99999 를 챙겨가져야함
# 근데 단순히 2중 포문해서 돌리기만 n*4 번 돌려서 하면 이거 못챙기지
# 그래서 하는 방법은 DP 를 사용해한데
# https://latte-is-horse.tistory.com/229
# 설명하자면 [[1,2,3,5],[5,6,7,8],[4,3,2,1]] 에서
# 1번째 행 6 번을 챙긴다고 가정해보자
# 그러면 0 행의 1, 3, 5 이 세개중 하나를 챙겨야지 6으로 갈 수 있다
# 문제는 최대값이니 1, 3, 5 중 최대값 + 6을 해주면 된다
def solution(land):
    m = len(land)
    d = [[i for i in land[0]]]
    d.extend([[0]*4 for _ in range(m-1)])
    for i in range(1, m):
        for j in range(4):
            a, b, c = [k for k in range(4) if k != j]
            d[i][j] = land[i][j] + max(d[i-1][a], d[i-1][b], d[i-1][c])

    return max(d[-1])


if __name__ == "__main__":
    land = [[1,2,3,5],[5,6,7,99999],[4,3,2,1]]
    res = 16
    answer = solution(land)
    print(res == answer, answer)